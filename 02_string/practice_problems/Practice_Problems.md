# String - Practice Problems

## Easy Problems

### 1. Valid Palindrome
**LeetCode:** #125

**Description:**
Given a string `s`, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

**Example:**
```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Approach Hint:** Use two pointers, skip non-alphanumeric characters.

---

### 2. Longest Common Prefix
**LeetCode:** #14

**Description:**
Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string.

**Example:**
```
Input: strs = ["flower", "flow", "flight"]
Output: "fl"
```

**Approach Hint:** Compare characters at same position across all strings.

---

### 3. Valid Parentheses
**LeetCode:** #20

**Description:**
Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

**Example:**
```
Input: s = "()[]{}"
Output: true
```

**Approach Hint:** Use a stack to match opening and closing brackets.

---

### 4. Implement strStr()
**LeetCode:** #28

**Description:**
Return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`.

**Example:**
```
Input: haystack = "hello", needle = "ll"
Output: 2
```

**Approach Hint:** Implement KMP or use built-in find.

---

### 5. Count and Say
**LeetCode:** #38

**Description:**
The count-and-say sequence is generated by describing the previous term. Given an integer n, return the nth term of the count-and-say sequence.

**Example:**
```
Input: n = 4
Output: "1211"
Explanation:
countAndSay(1) = "1"
countAndSay(2) = "11" (one 1)
countAndSay(3) = "21" (two 1s)
countAndSay(4) = "1211" (one 2, one 1)
```

**Approach Hint:** Iterate and count consecutive same characters.

---

## Medium Problems

### 6. Group Anagrams
**LeetCode:** #49

**Description:**
Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.

**Example:**
```
Input: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
Output: [["bat"], ["nat", "tan"], ["ate", "eat", "tea"]]
```

**Approach Hint:** Use sorted string as key in hash map, or use character count tuple as key.

---

### 7. Longest Substring Without Repeating Characters
**LeetCode:** #3

**Description:**
Given a string `s`, find the length of the longest substring without repeating characters.

**Example:**
```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with length 3.
```

**Approach Hint:** Use sliding window with hash map to track character positions.

---

### 8. Minimum Window Substring
**LeetCode:** #76

**Description:**
Given two strings `s` and `t`, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window.

**Example:**
```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: Minimum window is "BANC" which contains all characters of t.
```

**Approach Hint:** Use sliding window with character count tracking.

---

### 9. Encode and Decode Strings
**LeetCode:** #271

**Description:**
Design an algorithm to encode a list of strings to a string. The encoded string is then decoded back to the original list of strings.

**Example:**
```
Input: ["Hello", "World"]
Encoded: "5#Hello5#World"
Decoded: ["Hello", "World"]
```

**Approach Hint:** Use length prefix with delimiter for encoding.

---

## Hard Problems

### 10. Word Ladder II
**LeetCode:** #126

**Description:**
Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return all the shortest transformation sequences from `beginWord` to `endWord`.

**Example:**
```
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
```

**Approach Hint:** Use BFS to build graph, then DFS to find all shortest paths.

---

## Additional Practice

### Valid Anagram (Easy) - #242
Check if two strings are anagrams.

### Palindrome Number (Easy) - #9
Determine if integer is palindrome without converting to string.

### Add Binary (Easy) - #67
Add two binary strings.

### Longest Palindromic Substring (Medium) - #5
Find longest palindromic substring.

### String to Integer (atoi) (Medium) - #8
Convert string to 32-bit integer.

### Multiply Strings (Medium) - #43
Multiply two numbers represented as strings.

### Interleaving String (Medium) - #97
Check if s3 is formed by interleaving s1 and s2.

### Text Justification (Hard) - #68
Format text with full justification.

### Substring with Concatenation of All Words (Hard) - #30
Find all starting indices of substring containing all words exactly once.

---

## Problem-Solving Tips

1. **String immutability:** In Python, strings are immutable. Convert to list for in-place modifications.

2. **Efficient concatenation:** Use `''.join(list_of_strings)` instead of `+` in loops.

3. **Character operations:**
   - `ord('a')` → 97
   - `chr(97)` → 'a'
   - `'a'.isalnum()` → True

4. **Common patterns:**
   - Two pointers for palindrome/reverse
   - Sliding window for substring
   - Stack for matching/parsing
   - Hash map for anagram/frequency

5. **Edge cases:**
   - Empty string
   - Single character
   - All same characters
   - Unicode characters
