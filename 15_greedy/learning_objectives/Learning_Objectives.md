# Greedy - Learning Objectives

## Overview
Greedy algorithms make locally optimal choices at each step, hoping to find a global optimum. They work when the problem has optimal substructure and greedy choice property.

## Learning Objectives

### 1. Greedy Choice Property
- Understand what makes greedy algorithms work
- Learn to identify greedy-appropriate problems
- Understand when greedy fails vs succeeds
- Practice proving greedy correctness

### 2. Optimal Substructure
- Recognize problems with optimal substructure
- Understand how local choices lead to global optimum
- Learn to compare greedy vs dynamic programming
- Master problem decomposition

### 3. Classic Greedy Problems
- Master activity selection problem
- Learn interval scheduling and merging
- Practice jump game problems
- Solve gas station and candy problems

### 4. Greedy Techniques
- Sort and process pattern
- Two-pointer greedy approach
- Priority queue for greedy
- Proof by exchange argument

## Python-Specific Notes
- Sorting is often the first step in greedy
- Use lambda for custom sorting
- Consider heapq for priority-based greedy
- Track current state efficiently

## Success Criteria
- [ ] Solve activity selection problems
- [ ] Apply greedy to interval problems
- [ ] Solve jump game variants
- [ ] Implement candy distribution
- [ ] Recognize when greedy is appropriate
